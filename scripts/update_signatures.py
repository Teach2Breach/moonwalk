#!/usr/bin/env python3
"""
Signature Database to Rust Code Generator

This script reads function signatures from a SQLite database created by the signature builder
and generates hardcoded Rust code for signature_scanner.rs
"""

import sqlite3
import sys
from pathlib import Path

def connect_to_database(db_path):
    """Connect to the signature database"""
    try:
        conn = sqlite3.connect(db_path)
        return conn
    except sqlite3.Error as e:
        print(f"Error connecting to database: {e}")
        return None

def load_target_functions():
    """Load the list of target functions from target_functions.txt"""
    target_file = Path("target_functions.txt")
    if not target_file.exists():
        print(f"Warning: {target_file} not found, will include all functions")
        return None
    
    with open(target_file, 'r') as f:
        functions = [line.strip() for line in f if line.strip() and not line.startswith('#')]
    
    print(f"Loaded {len(functions)} target functions from {target_file}")
    return set(functions)

def get_signatures_from_db(conn, dll_name, windows_version, target_functions=None):
    """Get signatures for a specific DLL and Windows version, optionally filtered by target functions"""
    try:
        cursor = conn.cursor()
        
        if target_functions:
            # Create placeholders for the IN clause
            placeholders = ','.join(['?' for _ in target_functions])
            query = f"""
                SELECT function_name, signature_bytes, function_rva, signature_length
                FROM function_signatures 
                WHERE dll_name = ? AND windows_version = ? AND function_name IN ({placeholders})
                ORDER BY function_name
            """
            params = [dll_name, windows_version] + list(target_functions)
        else:
            query = """
                SELECT function_name, signature_bytes, function_rva, signature_length
                FROM function_signatures 
                WHERE dll_name = ? AND windows_version = ?
                ORDER BY function_name
            """
            params = [dll_name, windows_version]
        
        cursor.execute(query, params)
        
        signatures = []
        for row in cursor.fetchall():
            function_name, signature_bytes, function_rva, signature_length = row
            signatures.append({
                'name': function_name,
                'bytes': signature_bytes,
                'rva': function_rva,
                'length': signature_length
            })
        
        return signatures
    except sqlite3.Error as e:
        print(f"Error querying database: {e}")
        return []

def create_empty_placeholder(dll_name, windows_version):
    """Create an empty placeholder for the get_function_signatures function"""
    return '\n'.join([
        '// Database of function signatures',
        '// Generated from {db}_signatures_v2.db for Windows {ver}'.format(db=dll_name, ver=windows_version),
        '// This would be generated by the signature-builder tool',
        'pub fn get_function_signatures() -> Vec<FunctionSignature> {',
        '    vec![',
        '        // Signatures will be populated here',
        '    ]',
        '}'
    ])

def format_bytes_as_rust_array(bytes_data):
    """Format bytes as a Rust array literal"""
    hex_bytes = ["0x{:02x}".format(b) for b in bytes_data]
    # Format in rows of 8 bytes for readability
    formatted_lines = []
    for i in range(0, len(hex_bytes), 8):
        line_bytes = hex_bytes[i:i+8]
        formatted_lines.append("                " + ", ".join(line_bytes) + ",")
    return "\n".join(formatted_lines)



def update_signature_scanner(signatures, dll_name, windows_version):
    """Update the signature_scanner.rs file with new signatures"""
    scanner_path = Path("../src/signature_scanner.rs")
    if not scanner_path.exists():
        print(f"Error: {scanner_path} not found")
        return False

    with open(scanner_path, 'r') as f:
        content = f.read()

    import re
    
    # Step 1: Replace with empty placeholder first to clean up any existing signatures
    print("Step 1: Replacing with empty placeholder...")
    empty_placeholder = create_empty_placeholder(dll_name, windows_version)
    
    # Find the start of the function
    start_pattern = r'// Database of function signatures.*?pub fn get_function_signatures\(\) -> Vec<FunctionSignature> \{'
    match = re.search(start_pattern, content, flags=re.DOTALL)
    
    if not match:
        print("Warning: Could not find get_function_signatures function to replace")
        return False
    
    start_pos = match.start()
    
    # Find the matching closing brace for the function
    brace_count = 0
    in_function = False
    end_pos = start_pos
    
    for i in range(start_pos, len(content)):
        if content[i] == '{':
            if not in_function:
                in_function = True
            brace_count += 1
        elif content[i] == '}':
            brace_count -= 1
            if in_function and brace_count == 0:
                end_pos = i + 1
                break
    
    # Replace the entire function with empty placeholder
    content_with_empty = content[:start_pos] + empty_placeholder + content[end_pos:]
    
    # Step 2: Now build the actual signatures
    print("Step 2: Building signatures...")
    signature_entries = []
    for sig in signatures:
        entry_lines = [
            '        FunctionSignature {',
            '            name: "{name}".to_string(),'.format(name=sig["name"]),
            '            rva: {rva},'.format(rva=hex(int(sig["rva"]))),
            '            pattern: vec![',
            format_bytes_as_rust_array(sig["bytes"]),
            '            ],',
            '            offset: 12, // Function starts 12 bytes before pattern (to account for potential hooks)',
            '        }'
        ]
        entry = '\n'.join(entry_lines)
        signature_entries.append(entry)
    joined_entries = ",\n".join(signature_entries)

    # Step 3: Replace the empty placeholder with actual signatures
    print("Step 3: Replacing placeholder with signatures...")
    final_replacement = '\n'.join([
        '// Database of function signatures',
        '// Generated from {db}_signatures_v2.db for Windows {ver}'.format(db=dll_name, ver=windows_version),
        '// This would be generated by the signature-builder tool',
        'pub fn get_function_signatures() -> Vec<FunctionSignature> {',
        '    vec![',
        joined_entries,
        '    ]',
        '}'
    ])
    
    # Find and replace the empty placeholder with the final version
    start_pattern = r'// Database of function signatures.*?pub fn get_function_signatures\(\) -> Vec<FunctionSignature> \{'
    match = re.search(start_pattern, content_with_empty, flags=re.DOTALL)
    
    if not match:
        print("Warning: Could not find empty placeholder to replace")
        return False
    
    start_pos = match.start()
    
    # Find the matching closing brace for the function
    brace_count = 0
    in_function = False
    end_pos = start_pos
    
    for i in range(start_pos, len(content_with_empty)):
        if content_with_empty[i] == '{':
            if not in_function:
                in_function = True
            brace_count += 1
        elif content_with_empty[i] == '}':
            brace_count -= 1
            if in_function and brace_count == 0:
                end_pos = i + 1
                break
    
    # Replace the empty placeholder with the final version
    final_content = content_with_empty[:start_pos] + final_replacement + content_with_empty[end_pos:]

    with open(scanner_path, 'w') as f:
        f.write(final_content)

    return True

def main():
    if len(sys.argv) < 2:
        print("Usage: python update_signatures.py <dll_name> [windows_version]")
        print("Example: python update_signatures.py ntdll 10.0.26100")
        return
    
    dll_name = sys.argv[1]
    windows_version = sys.argv[2] if len(sys.argv) > 2 else "10.0.26100"
    db_path = f"{dll_name}_signatures_v2.db"
    print(f"Reading signatures from {db_path} for {dll_name} (Windows {windows_version})")

    # Load target functions
    target_functions = load_target_functions()
    
    conn = connect_to_database(db_path)
    if not conn:
        return

    signatures = get_signatures_from_db(conn, dll_name, windows_version, target_functions)
    conn.close()

    if not signatures:
        print(f"No signatures found for {dll_name} in Windows {windows_version}")
        return

    print(f"Found {len(signatures)} signatures")

    if update_signature_scanner(signatures, dll_name, windows_version):
        print(f"Successfully updated src/signature_scanner.rs with {len(signatures)} signatures")
        print(f"Database: {db_path}")
        print(f"Windows Version: {windows_version}")
    else:
        print("Failed to update signature_scanner.rs")

if __name__ == "__main__":
    main() 