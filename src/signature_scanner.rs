use std::collections::HashMap;
use crate::safe_read;

// Function signature structure
#[derive(Debug, Clone)]
pub struct FunctionSignature {
    pub name: String,
    pub rva: u32,
    pub pattern: Vec<u8>,
    pub offset: usize, // Offset from pattern start to function start
}

// Function information returned by scanner
#[derive(Debug, Clone)]
pub struct FunctionInfo {
    pub name: String,
    pub address: usize,
    pub rva: u32,
    pub validation_status: ValidationStatus,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ValidationStatus {
    Validated,
    Unvalidated,
    Failed(String),
}

// Database of function signatures
// Generated from ntdll_signatures_v2.db for Windows 10.0.26100
// This would be generated by the signature-builder tool
pub fn get_function_signatures() -> Vec<FunctionSignature> {
    vec![
        FunctionSignature {
            name: "NtAllocateVirtualMemory".to_string(),
            rva: 0x1620c0,
            pattern: vec![
                0x4c, 0x8b, 0xd1, 0xb8, 0x18, 0x00, 0x00, 0x00,
                0xf6, 0x04, 0x25, 0x08, 0x03, 0xfe, 0x7f, 0x01,
                0x75, 0x03, 0x0f, 0x05, 0xc3, 0xcd, 0x2e, 0xc3,
                0x0f, 0x1f, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
            ],
            offset: 12, // Function starts 12 bytes before pattern (to account for potential hooks)
        },
        FunctionSignature {
            name: "NtClose".to_string(),
            rva: 0x161fa0,
            pattern: vec![
                0x4c, 0x8b, 0xd1, 0xb8, 0x0f, 0x00, 0x00, 0x00,
                0xf6, 0x04, 0x25, 0x08, 0x03, 0xfe, 0x7f, 0x01,
                0x75, 0x03, 0x0f, 0x05, 0xc3, 0xcd, 0x2e, 0xc3,
                0x0f, 0x1f, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
            ],
            offset: 12, // Function starts 12 bytes before pattern (to account for potential hooks)
        },
        FunctionSignature {
            name: "NtCreateFile".to_string(),
            rva: 0x162860,
            pattern: vec![
                0x4c, 0x8b, 0xd1, 0xb8, 0x55, 0x00, 0x00, 0x00,
                0xf6, 0x04, 0x25, 0x08, 0x03, 0xfe, 0x7f, 0x01,
                0x75, 0x03, 0x0f, 0x05, 0xc3, 0xcd, 0x2e, 0xc3,
                0x0f, 0x1f, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
            ],
            offset: 12, // Function starts 12 bytes before pattern (to account for potential hooks)
        },
        FunctionSignature {
            name: "NtCreateThreadEx".to_string(),
            rva: 0x1636d0,
            pattern: vec![
                0x4c, 0x8b, 0xd1, 0xb8, 0xc9, 0x00, 0x00, 0x00,
                0xf6, 0x04, 0x25, 0x08, 0x03, 0xfe, 0x7f, 0x01,
                0x75, 0x03, 0x0f, 0x05, 0xc3, 0xcd, 0x2e, 0xc3,
                0x0f, 0x1f, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
            ],
            offset: 12, // Function starts 12 bytes before pattern (to account for potential hooks)
        },
        FunctionSignature {
            name: "NtFreeVirtualMemory".to_string(),
            rva: 0x162180,
            pattern: vec![
                0x4c, 0x8b, 0xd1, 0xb8, 0x1e, 0x00, 0x00, 0x00,
                0xf6, 0x04, 0x25, 0x08, 0x03, 0xfe, 0x7f, 0x01,
                0x75, 0x03, 0x0f, 0x05, 0xc3, 0xcd, 0x2e, 0xc3,
                0x0f, 0x1f, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
            ],
            offset: 12, // Function starts 12 bytes before pattern (to account for potential hooks)
        },
        FunctionSignature {
            name: "NtOpenFile".to_string(),
            rva: 0x162420,
            pattern: vec![
                0x4c, 0x8b, 0xd1, 0xb8, 0x33, 0x00, 0x00, 0x00,
                0xf6, 0x04, 0x25, 0x08, 0x03, 0xfe, 0x7f, 0x01,
                0x75, 0x03, 0x0f, 0x05, 0xc3, 0xcd, 0x2e, 0xc3,
                0x0f, 0x1f, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
            ],
            offset: 12, // Function starts 12 bytes before pattern (to account for potential hooks)
        },
        FunctionSignature {
            name: "NtProtectVirtualMemory".to_string(),
            rva: 0x1627c0,
            pattern: vec![
                0x4c, 0x8b, 0xd1, 0xb8, 0x50, 0x00, 0x00, 0x00,
                0xf6, 0x04, 0x25, 0x08, 0x03, 0xfe, 0x7f, 0x01,
                0x75, 0x03, 0x0f, 0x05, 0xc3, 0xcd, 0x2e, 0xc3,
                0x0f, 0x1f, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
            ],
            offset: 12, // Function starts 12 bytes before pattern (to account for potential hooks)
        },
        FunctionSignature {
            name: "NtQuerySystemTime".to_string(),
            rva: 0x162900,
            pattern: vec![
                0xe9, 0x2b, 0x12, 0xf9, 0xff, 0x66, 0x66, 0x66,
                0x0f, 0x1f, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x4c, 0x8b, 0xd1, 0xb8, 0x5b, 0x00, 0x00, 0x00,
                0xf6, 0x04, 0x25, 0x08, 0x03, 0xfe, 0x7f, 0x01,
            ],
            offset: 12, // Function starts 12 bytes before pattern (to account for potential hooks)
        }
    ]
}

// Pattern matching function with wildcard support
fn pattern_matches(data: &[u8], pattern: &[u8], wildcards: &[bool]) -> bool {
    if data.len() < pattern.len() {
        return false;
    }
    
    for (i, &pattern_byte) in pattern.iter().enumerate() {
        if i < wildcards.len() && wildcards[i] {
            continue; // Wildcard byte - skip comparison
        }
        
        if data[i] != pattern_byte {
            return false;
        }
    }
    
    true
}

// Scan for a specific function signature
pub fn find_function_by_signature(dll_base: usize, function_name: &str) -> Option<usize> {
    let signatures = get_function_signatures();
    
    // Find the signature for the requested function
    let signature = signatures.iter().find(|s| s.name == function_name)?;
    
    unsafe {
        // Get DLL size from PE headers (simplified - you may need to import this logic)
        let dos_header = dll_base as *const u32;
        let e_lfanew = match safe_read((dll_base + 0x3C) as *const u32) {
            Some(lfanew) => lfanew,
            None => return None,
        };
        
        let nt_headers = dll_base + e_lfanew as usize;
        let size_of_image = match safe_read((nt_headers + 0x50) as *const u32) {
            Some(size) => size,
            None => return None,
        };
        
        let pattern_len = signature.pattern.len();
        let search_end = dll_base + size_of_image as usize - pattern_len;
        
        // Scan through the DLL memory for the pattern
        for addr in (dll_base..=search_end).step_by(1) {
            // Read bytes at current address
            let mut current_bytes = Vec::new();
            for i in 0..pattern_len {
                match safe_read((addr + i) as *const u8) {
                    Some(byte) => current_bytes.push(byte),
                    None => break,
                }
            }
            
            if current_bytes.len() == pattern_len {
                // Check if pattern matches (no wildcards for now)
                let mut wildcards = vec![false; pattern_len];
                
                if pattern_matches(&current_bytes, &signature.pattern, &wildcards) {
                    // Found a match! Return the address
                    return Some(addr + signature.offset);
                }
            }
        }
    }
    
    None
}

// Scan for all functions in the database
pub fn scan_all_functions(dll_base: usize) -> Vec<FunctionInfo> {
    let mut functions = Vec::new();
    let signatures = get_function_signatures();
    
    for signature in &signatures {
        if let Some(address) = find_function_by_signature(dll_base, &signature.name) {
            functions.push(FunctionInfo {
                name: signature.name.clone(),
                address,
                rva: signature.rva,
                validation_status: ValidationStatus::Validated,
            });
        }
    }
    
    functions
}

// Get all available functions as a HashMap
pub fn get_available_functions(dll_base: usize) -> HashMap<String, usize> {
    let functions = scan_all_functions(dll_base);
    let mut result = HashMap::new();
    
    for func in functions {
        if func.validation_status == ValidationStatus::Validated {
            result.insert(func.name, func.address);
        }
    }
    
    result
}

// Debug function to print signature information
pub fn print_signature_info() {
    let signatures = get_function_signatures();
    
    println!("=== Function Signature Database ===");
    for sig in &signatures {
        println!("Function: {}", sig.name);
        println!("RVA: 0x{:X}", sig.rva);
        println!("Pattern ({} bytes):", sig.pattern.len());
        
        // Print pattern in hex format
        for (i, &byte) in sig.pattern.iter().enumerate() {
            if i % 16 == 0 {
                print!("\n  ");
            }
            print!("{:02x} ", byte);
        }
        println!("\n");
    }
}

// Test function to validate signatures
pub fn test_signature_scanning(dll_base: usize) {
    println!("=== Testing Hook-Resistant Signature Scanning ===");
    
    // Test finding NtQuerySystemTime
    if let Some(addr) = find_function_by_signature(dll_base, "NtQuerySystemTime") {
        println!("✓ Found NtQuerySystemTime at 0x{:X}", addr);
        
        // Print bytes around the found function to show hook-resistant approach
        unsafe {
            println!("Function bytes (showing hook-resistant pattern):");
            println!("First 16 bytes (potential hook area):");
            for i in 0..16 {
                if let Some(byte) = safe_read((addr + i) as *const u8) {
                    print!("{:02x} ", byte);
                } else {
                    print!("?? ");
                }
            }
            println!();
            
            println!("Pattern match area (bytes 12-27):");
            for i in 12..28 {
                if let Some(byte) = safe_read((addr + i) as *const u8) {
                    print!("{:02x} ", byte);
                } else {
                    print!("?? ");
                }
            }
            println!();
        }
    } else {
        println!("✗ Could not find NtQuerySystemTime");
    }
    
    // Test finding NtCreateFile (more likely to be hooked)
    if let Some(addr) = find_function_by_signature(dll_base, "NtCreateFile") {
        println!("✓ Found NtCreateFile at 0x{:X}", addr);
        
        // Print bytes around the found function
        unsafe {
            println!("NtCreateFile bytes (potential hook detection):");
            println!("First 16 bytes (check for hooks):");
            for i in 0..16 {
                if let Some(byte) = safe_read((addr + i) as *const u8) {
                    print!("{:02x} ", byte);
                } else {
                    print!("?? ");
                }
            }
            println!();
        }
    } else {
        println!("✗ Could not find NtCreateFile (may be hooked or signature needs update)");
    }
    
    // Test scanning all functions
    let all_functions = scan_all_functions(dll_base);
    println!("\nFound {} functions:", all_functions.len());
    for func in &all_functions {
        println!("  {} at 0x{:X} (RVA: 0x{:X})", func.name, func.address, func.rva);
    }
    
    println!("\n=== Hook-Resistant Approach Summary ===");
    println!("• Signatures start matching from byte 12 (skipping potential hook bytes)");
    println!("• Functions are found by matching deeper in their code");
    println!("• This approach works even if EDR hooks the function entry point");
    println!("• NtCreateFile is commonly hooked - good test case for EDR detection");
} 